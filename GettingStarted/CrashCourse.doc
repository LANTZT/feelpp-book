/* -*- mode: c++; coding: utf-8 -*- */
namespace Feel{
/** \page CrashCourse Crash Course

\tableofcontents

<hr>

This chapter is designed for impatient people who want to test \feel as soon as possible.
\section Requirements Requirements
Before installing \feel, you need to get these required packages:
\li g++ (4.7 or higher) OR Clang (3.3 or higher)
\li MPI: openmpi (preferred) or mpich
\li Boost (1.39 or higher)
\li Petsc (2.3.3 or higher)
\li Cmake (2.6 or higher)
\li Gmsh (2.8.3 or higher, can be found at <a href="http://www.geuz.org/gmsh">http://www.geuz.org/gmsh</a>)
\li Libxml2
It is assumed that all these packages are properly installed.

\section Building Building Feel++ from source on *nix
\feel is distributed as a tarball once in a while. The tarballs are available
at <br>
<center>https://github.com/feelpp/feelpp/releases</center>

Download the latest tarball. Then follow the steps and replace
 <tt>x, y, z </tt>with the corresponding numbers

\verbatim
  tar xzf feel-x.y.z.tar.gz
  cd feel-x.y.z
\endverbatim
We define then the current directory as the source one, ie:
\verbatim
  export FeelppSrcDir=`pwd`
\endverbatim

<a href="#" class="top">top</a>
<hr>
\section Compiling Compiling
Please note that 4 GBytes of RAM is a minimum to compile \feel with <tt><a href="http://www.gnu.org">GCC</a></tt>.
With <a href="http://www.llvm.org/clang">Clang</a>, the memory footprint is much lower.

In order to compile \feel and a test application, we create a new directory:
\verbatim
  mkdir build
  cd build
  export FeelppBuildDir=`pwd`
\endverbatim
<br>
and then, we are able to compile our first application:
\verbatim
  cd $FeelppBuildDir
  $FeelppSrcDir/configure -r
  make -j4
\endverbatim
<br>
This procedure will build the whole library (with Release configuration) and
programs to solve
 \li laplacian problems \f$-\Delta u=1 \mbox{ in } \Omega,\ u=g \mbox{ on } \partial \Omega\f$
 \li a Stokes problem \f$-\Delta \mathbf{u} + \nabla p = 0 \mbox{ in } \Omega,\ \mathbf{u}=\mathbf{0} \mbox{ on } \Gamma_\mathrm{wall}, \mathbf{u}=\mathbf{g} \mbox{ on } \Gamma_\mathrm{inlet}\f$ and free outflow \f$\left(-p \mathbb{I} + \nabla \mathbf{u}\right) \cdot \mathbf{n} = \mathbf{0} \mbox{ on } \Gamma_\mathrm{outlet}\f$
on arbitrary geometries in 2D by default to present \feel's abilities.

\remark
There is a procedure to install as a system library \feel.
\verbatim
  make install
\endverbatim
See page \ref BuildingP for more details.

<a href="#" class="top">top</a>
<hr>
\section QSLaplacian Laplacian with Dirichlet boundary conditions

As an introduction to the aim and the way to do with \feel, we provide a sort of
<tt>Hello World</tt> program to evaluate the library.

\subsection Math Problem setup

We want to solve the following problem:<br>
\f[ - \Delta u = 1,\quad u_{|\partial \Omega} = g \f]
where \f$\Omega \in \mathbb{R}^n, n\in{1,2,3}\f$.<br>

The variational form reads: looks for \f$u \in H^1_g\left( \Omega \right) = \{ v \in H^1(\Omega) | v = g \mbox{ on } \partial \Omega \}\f$
such that
\f[a\left( u,v \right) = l\left( v \right)\quad \forall v \in H^1\left( \Omega \right).\f]
with:
\f[a\left( u,v \right) = \int_{\Omega} \nabla u \cdot \nabla v ,\quad l\left( v \right) = \int_{\Omega} v \f]

The aim of \feel is to provide the simplest way to write the \f$a\f$ and \f$l\f$
forms.

From a discrete point of view, we introduce \f$V_h\subset H^1\left( \Omega \right)\f$ such that:
<br><center>\f$
  \begin{aligned}
V_h = \left\{ v \in C^0\left( \Omega \right), \forall K\in \mathcal{T}_h, \right.v\left|_K \in P_1\left( K \right) \right\},
    \end{aligned}
\f$</center><br>
where \f$\mathcal{T}_h\f$ is the set of element \f$K\f$ forming the mesh of \f$\Omega\f$. <br>
We now look for \f$u_h \in V_h\f$ such that:
<br><center>\f$
  \begin{aligned}
    \forall v_h\in V_h, a\left( u_h,v_h \right)=l\left( v_h \right).
    \end{aligned}
\f$</center><br>

\subsection Code About the code
This section is here to declare that we want to use the namespace \feel, to
passe the command line options to the created environnement and add some
informations (basics \feel options, application name).
\co
using namespace Feel;
Environment env( _argc=argc, _argv=argv,
                 _desc=feel_options(),
                 _directory=".",
                 _about=about(_name="qs_laplacian",
                 _author="Feel++ Consortium",
                 _email="feelpp-devel@feelpp.org"));
\eco
We have to define the mesh, the approximation space and our test and trial
functions.
\co
auto mesh = unitSquare();
auto Vh = Pch<1>( mesh );
auto u = Vh->element();
auto v = Vh->element();
\eco
We create now our bilinear and linear forms, we add the homogeneous Dirichlet
conditions and solve the discretized (linear) system.
\co
auto l = form1( _test=Vh );
l = integrate(_range=elements(mesh),
              _expr=id(v));

auto a = form2( _trial=Vh, _test=Vh );
a = integrate(_range=elements(mesh),
              _expr=gradt(u)*trans(grad(v)) );

a+=on(_range=boundaryfaces(mesh), _rhs=l, _element=u,
      _expr=constant(0.) );
a.solve(_rhs=l,_solution=u);
\eco
\feel provides the possibility to save the results:
\co
auto e = exporter( _mesh=mesh );
e->add( "u", u );
e->save();
return 0;
\eco

<a href="#" class="top">top</a>
<hr>
\section First First execution & visualization

To test that part of code, please go to:
\verbatim
  cd $FeelppBuildDir/quickstart
\endverbatim
and execute the code, by:
\verbatim
  ./feelpp_qs_laplacian
\endverbatim
This will produce several files in directory <tt>$HOME/feel/qs_laplacian/np_1/</tt>:
\verbatim
  feel.geo
  feel.msh
  qs_laplacian-1_0.case
  qs_laplacian-1_0.geo
  qs_laplacian-1.sos
  qs_laplacian-paraview-1.sos
  qs_laplacian.timeset
  qs_laplacian.u-1_0.001
\endverbatim
You can visualize the results using any Ensight file reader, such as Paraview,
opening <tt>qs_laplacian-paraview-1.sos</tt>.
\verbatim
  paraview qs_laplacian-paraview-1.sos
\endverbatim
You may have a look to the numerous options provided by
\verbatim
  ./feelpp_qs_laplacian --help
\endverbatim



*/
}
