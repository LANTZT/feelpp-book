= Interpolation


Feel++ has a very powerful interpolation framework which allows to seamlessly in parallel:
 - transfer functions from one mesh to another
 - transfer functions from one space type to another.

The framework provides a set of C++ classes and C++ free-functions enabled  short, concise and expressive handling of interpolation.

== Using interpolation operator

[source,cpp]
--
using MeshType = Mesh<Simplex<2>>;
auto mesh loadMesh( _mesh=new MeshType );
auto P1h = Pch<1>( mesh );
auto P0h = Pdh<0>( mesh );
auto Ih = I( _domain=P1h, _image=P0h ); 
--

== De Rahm Diagram

The De Rahm diagram reads as follows: the range of each of the operators coincides with the null space of the next operator in the sequence below, and the last map is a surjection. 


latexmath:[\begin{array}{ccccccccccc}
      \mathbb{R}& 
      \overset{id}{\longrightarrow}&
      H_1(\Omega)&
      \overset{\nabla}{\longrightarrow}&
      H_{\mathrm{curl}}(\Omega)&
      \overset{\nabla \times}{\longrightarrow}&
      H_{\mathrm{div}}(\Omega)&
      \overset{\nabla \cdot}{\longrightarrow}&
      L_2(\Omega)&
      \overset{0}{\longrightarrow} \{0\} \\
      ~ &
      ~ & 
      \left\downarrow\right.\pi_h&
      ~ & 
      \left\downarrow\right.\pi_h&
      ~ &
      \left\downarrow\right.\pi_h&
      ~ &
      \left\downarrow\right.\pi_h&
      ~ &
      ~ \\
      \mathbb{R}& 
      \overset{id}{\longrightarrow}&
      U_h&
      \overset{\nabla}{\longrightarrow}&
      V_h&
      \overset{curl}{\longrightarrow}&
      W_h&
      \overset{div}{\longrightarrow}&
      Z_h&
      \overset{0}{\longrightarrow} \{0\} \\
    \end{array}]
    
> **Note** The diagram can be restricted to functions
satisfying the homogeneous Dirichlet boundary conditions 

[source,cpp]
--
auto mesh = loadMesh( _mesh=new Mesh<Simplex<Dim>>());
auto Xh = Pch<1>(mesh);
auto Gh = Ned1h<0>(mesh);
auto Ch = Dh<0>(mesh);
auto P0h = Pdh<0>(mesh);
auto Igrad = Grad( _domainSpace = Xh, _imageSpace=Gh );
auto Icurl = Curl( _domainSpace = Gh, _imageSpace=Ch );
auto Idiv = Div( _domainSpace = Ch, _imageSpace=P0h );

auto u = Xh->element(<expr>);
auto w = Igrad(u); // w in Gh
auto x = Icurl(w); // z in Ch
auto y = Idiv(x); // y in P0h
--