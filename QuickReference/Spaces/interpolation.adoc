= Interpolation


Feel++ has a very powerful interpolation framework which allows to seamlessly in parallel:
 - transfer functions from one mesh to another
 - transfer functions from one space type to another.

The framework provides a set of C++ classes and C++ free-functions enabled  short, concise and expressive handling of interpolation.

== Using interpolation operator

[source,cpp]
--
using MeshType = Mesh<Simplex<2>>;
auto mesh loadMesh( _mesh=new MeshType );
auto P1h = Pch<1>( mesh );
auto P0h = Pdh<0>( mesh );
auto Ih = I( _domain=P1h, _image=P0h ); 
--

== De Rahm Diagram

The De Rahm diagram reads as follows: the range of each of the operators coincides with the null space of the next operator in the sequence below, and the last map is a surjection. 

latexmath:[\begin{array}{cccccccccc}
      \mathbb{R}& 
      \overset{id}{\longrightarrow}&
      H^1(\Omega)&
      \overset{\nabla}{\longrightarrow}&
      H^{\mathrm{curl}}(\Omega)&
      \overset{\nabla \times}{\longrightarrow}&
      H^{\mathrm{div}}(\Omega)&
      \overset{\nabla \cdot}{\longrightarrow}&
      L^2(\Omega)
    \end{array}]
    
An important result is that the diagram transfers to the discrete level
latexmath:[\begin{array}{cccccccccc}
      \mathbb{R}& 
      \overset{id}{\longrightarrow}&
      H^1(\Omega)&
      \overset{\nabla}{\longrightarrow}&
      H^{\mathrm{curl}}(\Omega)&
      \overset{\nabla \times}{\longrightarrow}&
      H^{\mathrm{div}}(\Omega)&
      \overset{\nabla \cdot}{\longrightarrow}&
      L^2(\Omega) \\
      ~ &
      ~ & 
      \left\downarrow\right.\pi_{c,h}&
      ~ & 
      \left\downarrow\right.\pi_{\mathrm{curl},h}&
      ~ &
      \left\downarrow\right.\pi_{\mathrm{div},_h}&
      ~ &
      \left\downarrow\right.\pi_{d,h}&
      ~ \\
      \mathbb{R}& 
      \overset{id}{\longrightarrow}&
      U_h&
      \overset{\nabla}{\longrightarrow}&
      V_h&
      \overset{\nabla \times}{\longrightarrow}&
      W_h&
      \overset{\nabla \cdot}{\longrightarrow}&
      Z_h\\
    \end{array}]

The diagram above is commutative which means that we have the following properties:

latexmath:[\begin{aligned}
\nabla(\pi_{c,h} u) &= \pi_{\mathrm{curl},h}( \nabla u ),\\ \nabla\times(\pi_{\mathrm{curl},h} u) &= \pi_{\mathrm{div},h}( \nabla\times u ),\\
\nabla\cdot(\pi_{\mathrm{div},h} u) &= \pi_{d,h}( \nabla\cdot u )
\end{aligned}]
    
> **Note** The diagram can be restricted to functions
satisfying the homogeneous Dirichlet boundary conditions 
latexmath:[\begin{array}{cccccccccc}
      \mathbb{R}& 
      \overset{id}{\longrightarrow}&
      H^1_0(\Omega)&
      \overset{\nabla}{\longrightarrow}&
      H_0^{\mathrm{curl}}(\Omega)&
      \overset{\nabla \times}{\longrightarrow}&
      H_0^{\mathrm{div}}(\Omega)&
      \overset{\nabla \cdot}{\longrightarrow}&
      L^2_0(\Omega)
    \end{array}]

.Table List of Interpolation operators
|===
| C++ call | Mathematical operator 
| `I(_domain=Xh,_image=Yh)` | latexmath:[I X_h \rightarrow Yh ]
| `Grad(_domain=Xh,_image=Wh)` | latexmath:[\nabla: X_h \rightarrow Wh ]
| `Curl(_domain=Wh,_image=Vh)` | latexmath:[\nabla \times W_h \rightarrow Vh ]
| `Div(_domain=Vh,_image=Zh)` | latexmath:[\nabla \cdot: V_h \rightarrow Zh ]
|===
[source,cpp]
--
auto mesh = loadMesh( _mesh=new Mesh<Simplex<Dim>>());
auto Xh = Pch<1>(mesh);
auto Gh = Ned1h<0>(mesh);
auto Ch = Dh<0>(mesh);
auto P0h = Pdh<0>(mesh);
auto Igrad = Grad( _domainSpace = Xh, _imageSpace=Gh );
auto Icurl = Curl( _domainSpace = Gh, _imageSpace=Ch );
auto Idiv = Div( _domainSpace = Ch, _imageSpace=P0h );

auto u = Xh->element(<expr>);
auto w = Igrad(u); // w in Gh
auto x = Icurl(w); // z in Ch
auto y = Idiv(x); // y in P0h
--