= Bilinear and Linears Forms

We consider in this section bilinear and linear forms
latexmath:[a: X_h \times X_h \rightarrow \mathbb{R}] 
and 
latexmath:[\ell: X_h \rightarrow \mathbb{R}].


We suppose in this section that you know how to define your [Mesh](mesh.md) and your [function spaces](spaces.md). You may need integration tools too, [see  Integrals](integrals.md).

There are Feel++ tools you need to create linear and bilinear forms in order to solve variational formulation.

> **Note** from now on, `u`  denotes an element from your trial function space (unknown function) and  `v` an  element from your test function space

== Building Forms

=== Using `form1`

To construct a linear form latexmath:[\ell: X_h \rightarrow \mathbb{R}], proceed as follows
```cpp
auto mesh = ...;
// build a P1/Q1 approximation space
auto Xh = Pch<1>( mesh );
auto l = form1(_test=Xh);
```

Required Parameters:
* `_test`  test function space.

==== Example

From `mylaplacian.cpp`   
marker_form1   

```c++   
// right hand side
    auto l = form1( _test=Vh );
    l = integrate(_range=elements(mesh), _expr=id(v));
```

From `myadvection.cpp`   

```c++
    // right hand side
    auto l = form1( _test=Xh );
    l+= integrate( _range=elements( mesh ), _expr=f*id( v ) );
```




> **Note** The operators `+=` and `=` are supported by linear and bilinear forms.
```cpp
auto a1 = form2(_test=Xh,_trial=Xh);
auto a2 = form2(_test=Xh,_trial=Xh);
// operations on a2 ...
// check that they have the same type and 
// copy matrix associated to a2 in a1
a1 = a2; 
```


=== Using `form2`
==== Interface
```cpp
form2(_trial, _test, _init);
```
Required Parameters:
* `_trial`  test function space
* `_test`  trial function space

Optional Parameters:
* `_init`  Default = `false.`

By default, a new bilinear form is:
$$
a(u,v)=\int_\Omega uv
$$
Then you can custom it using integrations tools

=== Example
From `mylaplacian.cpp`   
 
 ```c++
    // left hand side
    auto a = form2( _trial=Vh, _test=Vh );
    a = integrate(_range=elements(mesh),
                  _expr=gradt(u)*trans(grad(v)) );

 ```

From `mystokes.cpp`:   

```c++
    // left hand side
    auto a = form2( _trial=Vh, _test=Vh );
    a = integrate(_range=elements(mesh),
                  _expr=trace(gradt(u)*trans(grad(u))) );
    a+= integrate(_range=elements(mesh),
                  _expr=-div(u)*idt(p)-divt(u)*id(p));

```

> **Note** see note above on operators `+=` and `=`



== Solver 

In this section we present syntax to solve variational formulations. For more general linear problems see  Linear.

=== solve 

Once you created your linear and bilinear forms you can use the `solve()`  function on your bilinear form. The `solve()`  function presented there is a method from the class `BilinearForm.` 

==== Interface

```cpp
solve(_solution, _rhs, _rebuild, _name);
```
Required Parameters:
* `_solution`  the solution.
* `_rhs`  right hand side. The linear form.

Optional Parameters:
* `_rebuild`  rebuild the solver matrix. Default = `false.`
* `_name`  Default = "".

### Example
From `laplacian.cpp`:   


 ```c++
     // solve the equation  a(u,v) = l(v)  
        a.solve(_rhs=l,_solution=u);
```

=== Using `on`

The function `on()`  allows you to add conditions to your bilinear form before using the `solve`  function.<br>

==== Interface

```cpp
on(_range, _rhs, _element, _expr);
```
Required Parameters:
* `_range`  domain concerned by this condition (see \ref Integrals ).
* `_rhs`  right hand side. The linear form.
* `_element`  element concerned.
* `_expr`  the condition.

This function is used with += operator.

==== Example

From `mylaplacian.cpp`:   
  
```c++
    // apply the boundary condition
    a+=on(_range=boundaryfaces(mesh), _rhs=l, _element=u,
          _expr=expr(soption("functions.alpha")) );
```

There we add the condition: $$ u  =  0  \text{ on }\;\partial\Omega \;$$.

From `mystokes.cpp`:   
marker_on   
[source,cpp]
--
    a+=on(_range=boundaryfaces(mesh), _rhs=l, _element=u,
          _expr=expr<2,1,5>(u_exact,syms));
--

You can also apply boundary conditions using :
[source,cpp]
--
  a+=on(_range=markedfaces(mesh,"top"),
        _element=u[Component::Y],
        _rhs=l,
        _expr=cst(0.))
--
