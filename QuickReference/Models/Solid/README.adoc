= Solid Mechanics Models
:toc:
:toc-placement: macro
:toclevels: 2

toc::[]

== Models 

{% include "SaintVenantKirchhoff.adoc" %}

== Json file

Let's describe how a json file is build.

=== Properties

* Linear 
* Saint-Venant-Kirchhoff
* NeoHookean

When materials are closed to incompressibility formulation in displacement/pressure are available.

.Table of Models for `model` option
|===
| Model | Name 

| Linear Elasticity 
| `Elasticity`

| Hyper Elasticity 
| `Hyper-Elasticity`

|===

.Table of Models for `material_law` in hyper elasticity
|===
| Model | Name   | Volumic law

| Saint-Venant-Kirchhoff
| `SaintVenantKirchhoff`
| classic, simo1985

| NeoHookean
| `NeoHookean`
| classic, simo1985

|===

option: `mechanicalproperties.compressible.volumic_law`

== Materials

[source,json]
.Materials section
----
"Materials":
{
    "marker":
    {
        "name":"solid",
        "E":"1.4e6",
        "nu":"0.4",
        "rho":"1e3"
    }
}
----

where `E` stands for the Young's modulus in $$Pa$$, `nu` the Poisson's ratio and `rho` the density in $$kg\cdot m^{-3}$$ .

=== Boundary Conditions

Boundary conditions and volumic forces are set in the json files
[source,json]
.Example for boundary conditions
----
"BoundaryConditions":
{
    "field":
    {
        "<condition type>":
        {
            "marker":
            {
                "expr": "value"
            }
        }
    }
}
----
where all component of vectorial field can be access with `<field>_x` for the $$x$$ component where `<field>` is the name of the vectorial field. +
The condition types are explain in the two following tables.

.Boundary conditions
|===
| Name | Options | Type 

| Dirichlet 
| faces, edges and component-wise
| "Dirichlet"

| Neumann 
| scalar, vectorial
| "Neumann_scalar" or "Neumann_vectorial"

| Pressure follower ,
| Nonlinear boundary condition set in deformed domain
| TODO

| Robin 
| TODO
| TODO

|===

.Volumic forces
|===
| Name | Options | Type

| Expression
| Vectorial
| "VolumicForces"

|===

=== Post Process

[source,json]
----
"PostProcess":
{
    "Fields":["field1","field2",...],
    "Measures":
    {
        "<measure type>":
        {
            "label":
            {
                "<range type>":"value",
                "fields":["field1","field3"]
            }
        }
    }
}
----

The fields allowed to be exported in the `Fields` section are:

- displacement
- velocity
- acceleration
- stress or normal-stress
- pressure
- material-properties
- pid
- fsi
- Von-Mises
- Tresca
- principal-stresses
- all

.Measure type and range type associated
|===
|Measure type | Range type | example

|Points | coords | "{0,0,0}"
|Maximum | markers | "marker1"
|Minimum | markers | "marker1"
|volume_variation* | - | "volume_variation":""
|===

*volume_variation does not take a set of point or of range, it is a volumic measure.

The fields on which one can do measures:

- volume_variation
- displacement
- velocity
- acceleration
- pressure
- principal-stress-0
- principal-stress-1
- principal-stress-2
- sigma_xx, sigma_xy, ...

== Action

Let's finish with a simple example in order to show how this works and how to use them. We will interest us to the deformation of an elastic structure.

=== Feel++ code
Here is the code 

[source,cpp]
----
{% include "../Examples/solid_model.cpp" %}
----

First at all, we define our model type with 

----
typedef FeelModels::SolidMechanics< Simplex<FEELPP_DIM,1>,
                                    Lagrange<OrderDisp, Vectorial,Continuous,PointSetFekete> > model_type;
----

We choose here $$\mathbb{P}_1$$ space for displacement order. This definition allows us to create our fluid model object SM like this
 
----
auto SM = model_type::New("solid");
----

The method `New` retrieve all data from the configuration and json files, as well build a mesh if need.

With this object, we can initialize our model parameters, such as velocity or boundaries conditions. Data on our model and on the numeric solver are then save and print on the terminal. This is made by 

----
FM->init();
FM->printAndSaveInfo();
----

Now that our model is completed, we can solve the associated problem. To begin the resolution

----
FM->isStationary()
----

determine if our model is stationary or not.

If it is, then we need to solve our system only one time and export the obtained results.

----
FM->solve();
FM->exportResults();
----

If it's not, our model is time reliant, and a loop on time is necessary. Our model is then solve and the results are export at each time step.

----
 for ( ; !FM->timeStepBase()->isFinished(); FM->updateTimeStep() )
        {
            FM->solve();
            FM->exportResults();
        }
----

=== Config and Json files
Then the configuration and the associated Json files

==== Config 
[source,cfg]
----
{% include "../Examples/csm3.cfg" %}
----

The config file is used to define options  linked to our case we would have the possibility to change at will. It can be, for example, files paths as follows

----
[solid]
filename=$top_srcdir/applications/models/solid/TurekHron/csm3.json

# precondtioner config
geofile=$top_srcdir/applications/models/solid/TurekHron/csm.geo

[exporter]
directory=applications/models/solid/TurekHron/csm3/$solid_tag

----

It can also be resolution dependent parameters such as mesh elements size, methods used  to define our problem and solvers.

----
[solid]

material_law=StVenantKirchhoff# StVenantKirchhoff, NeoHookean

# use density and material coeff cst in appli
jacobian-linear-update=false
linearsystem-cst-update=false

# snes and ksp config
#reuse-prec=true#false
#reuse-jac=true#false
reuse-jac.rebuild-at-first-newton-step=true
reuse-prec.rebuild-at-first-newton-step=true
snes-maxit=500
snes-maxit-reuse=10
snes-ksp-maxit=1000
snes-ksp-maxit-reuse=100

# precondtioner config
pc-type=lu #lu,gasm,ml
ksp-converged-reason=1
----
In this case, we use the Saint-Venant-Kirchhoff model to  define our problem, we set the update of linear system constant and jacobian linear as "no update", we discretize values associated to solvers ( SNES and KSP ), and finally we choose LU as the preconditioner method.


==== Json
[source,json]
----
{% include "../Examples/csm3.json" %}
----

First at all, we define some general information like the name ( and short name ) and the model we would like to use

[source,json]
----
"Name": "Solid Mechanics ",
"ShortName":"Solid",
"Model":"Hyper-Elasticity",
----

Then we define parameters we will need to solve our problem. Here we define a gravitational constant.

----
"Parameters":
    {
        "gravity":
        {
            "value":"2"
        }
    },
----

After that, we define the link:#Material[material properties]. In our case, we define the solid we will study, named beam here, by $$E$$, $$\nu$$ and $$\rho$$, respectively its Young's modulus ( $$kg/ms^2$$ ), its Poisson's ratio ( dimensionless ) and its density (in $$kg/m^3$$)

[source,json]
----
Materials":
    {
        "beam":{
            "name":"solid",
            "E":"1.4e6",
            "nu":"0.4",
            "rho":"1e3"
        }
    },
----

The link:#Boundary_Conditions[boundary conditions] are the next aspect we define. Here, we impose on the displacement several conditions :

- A Dirichlet condition on fixed wall
- A Neumann condition on free wall
- A volumic force, represent here by the action of the gravity on the solid.

[source,json]
----
BoundaryConditions":
    {
        "displacement":
        {
            "Dirichlet":
            {
                "fixed-wall":
                {
                    "expr":"{0,0}"
                }
            },
            "Neumann_scalar":
            {
                "free-wall":
                {
                    "expr":"0"
                }
            },
            "VolumicForces":
            {
                "":
                {
                    "expr":"{0,-gravity*1e3}:gravity"
                }
            }
        }
    },
----

The link:#Post_Process[post process] aspect is the last one to define. We choose the fields we want to export ( velocity, pressure and pid ). Furthermore, we want to measure forces on `wall` and the pressure at point $$A$$.

[source,json]
----
PostProcess":
    {
        "Fields":["displacement"],
        "Measures":
        {
            "Points":
            {
                "pointA":
                {
                    "coord":"{0.6,0.2,0}",
                    "fields":["displacement","velocity"]
                }
            },
            "Maximum":
            {
                "free-wall":
                {
                    "markers":"free-wall",
                    "fields":["displacement","velocity"]
                }
            }
        }
    }

----