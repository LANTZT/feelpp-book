= Eigen Problem

To resolve eigen problems, Feel++ interfaces http://slepc.upv.es[SLEPc]. SLEPc is a library which extends PETSc to provide the functionality necessary for the solution of eigenvalue problem. It comes with many solvers for both standard and generalized problems, Hermitian or not.

== Problem type

The standard formulation reads :

Find $$\lambda\in \mathbb{R}$$ such that $$Ax = \lambda x$$

where $$\lambda$$ is an eigenvalue and $$x$$ an eigenvector.

But in the case of the finite element method, we will deal with the generalized form :

Find $$\lambda\in\mathbb{R}$$such that $$Ax = \lambda Bx$$

A standard problem is Hermitian if the matrix $$A$$ is Hermitian ($$A=A^*$$). +
A generalized problem is Hermitian if the matrices $$A$$ and $$B$$ are Hermitian and if $$B$$ is positive definite. +
If the problem is Hermitian, then the eigenvalues are real.
A special case of the generalized problem is when the matrices are not Hermitian but \(B\) is positive definite.

The type of the problem can be specified using the EigenProblemType, or at run time with the command line option `--solvereigen.problem` and the following value :

.Table of problem type
[options="header"]
|===
| Problem type | EigenProblemType | command line key
|Standard Hermitian | HEP | "hep"
|Standard non-Hermitian | NHEP | "nhep"
|Generalized Hermitian | GHEP | "ghep"
|Generalized non-Hermitian | GNHEP | "gnhep"
|Positive definite Generalized non-Hermitian | PGNHEP | "pgnhep"
|===

== Position of spectrum

You can choose which eigenpairs will be computed. The user can set it programmatically with `PositionOfSpectrum` or at run time with the command line option `--solvereigen.spectrum` and the following value :

.Table of position of spectrum
[options="header"]
|===
|Position of spectrum | PositionOfSpectrum | command line key
|Largest magnitude | LARGEST_MAGNITUDE | "largest_magnitude"
|Smallest magnitude | SMALLEST_MAGNITUDE | "smallest_magnitude"
|Largest real | LARGEST_REAL | "largest_real"
|Smallest real | SMALLEST_REAL | "smallest_real"
|Largest imaginary | LARGEST_IMAGINARY | "largest_imaginary"
|Smallest imaginary | SMALLEST_IMAGINARY | "smallest_imaginary"
|===

== Spectral transformation

It is observed that the algorithms used to solve the eigenvalue problems find solutions at the extremities of the spectrum. To improve the convergence, one need to compute the eigenpairs of a transformed operator. Those spectral transformations allow to compute solutions that are not on the boundary of the spectrum.

There are 3 types of spectral transformation:

Shift:: $$A-\sigma I$$ or $$B^{-1}A-\sigma I$$
Shift and invert:: $$(A-\sigma I)^{-1}$$ or $$(A-\sigma B)^{-1}B$$
Cayley:: $$(A-\sigma I)^{-1}(A+\nu I)$$ or $$(A-\sigma B)^{-1}(A+\nu B)$$

By default, shift and invert is used. You can change it with `--solvereigen.transform`.

.Table of spectral transformation
[options="header"]
|===
| Spectral transformation | SpectralTransformationType | command line key
| Shift | SHIFT | shift
| Shift and invert | SINVERT | shift_invert
| Cayley | CAYLEY | cayley
|===

== Eigensolvers

The details of the implementation of the different solvers can be found in the http://slepc.upv.es/documentation/manual.htm[SLEPc Technical Reports].

The default solver is Krylov-Schur, but can be modified using `EigenSolverType` or the option `--solvereigen.solver`.

.Table of eigensolver
[options="header"]
|===
| Solver | EigenSolverType | command line key
| Power | POWER | power
| Lapack | LAPACK | lapack
| Subspace | SUBSPACE | subspace
| Arnoldi | Arnoldi | arnoldi
| Lanczos | LANCZOS | lanczos
| Krylov-Schur | KRYLOVSCHUR | krylovschur
| Arpack | ARPACK | arpack
|===

Be careful that all solvers can not compute all the problem types and positions of the spectrum. The possibilities are summarize in the following table.

.Supported problem type for the eigensolvers
[options="header"]
|===
| Solver | Position of spectrum | Problem type
| Power | Largest magnitude | any
| Lapack | any | any
| Subspace | Largest magnitude | any
| Arnoldi | any | any
| Lanczos | any | standard and generalized Hermitian
| Krylov-Schur | any | any
| Arpack | any | any
|===

== Special cases of spectrum

=== Computing a large portion of the spectrum

In the case where you want compute a large number of eigenpairs, the rule for `ncv` implies a huge amount of memory to be used. To improve the performance, you can set the `mpd` parameter, which will limit the dimension of the projected problem.

You can set it via the command line with `--solvereigen.mpd <mpd>`.

=== Computing all the eigenpairs in a interval

If you want to compute all the eigenpairs in a given interval, you need to use the option `--solvereigen.interval-a` to set the beginning of the interval and `--solvereigen.interval-b` to set the end.

In this case, be aware that the problem need to be generalized and hermitian. The solver will be set to Krylov-Schur and the transformation to shift and invert. Beside, you'll need to use a linear solver that will compute the inertia of the matrix, this is set to Cholesky, with mumps if you can use it.
