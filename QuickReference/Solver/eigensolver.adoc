= Eigen Problem

To resolve eigen problems, Feel++ interfaces http://slepc.upv.es[SLEPc]. SLEPc is a library which extends PETSc to provide the functionality necessary for the solution of eigenvalue problem. It comes with many solvers for both standard and generalized problems, Hermitian or not.

== Problem type

The standard formulation reads :

Find $$\lambda\in \mathbb{R}$$ such that $$Ax = \lambda x$$

where $$\lambda$$ is an eigenvalue and $$x$$ an eigenvector.

But in the case of the finite element method, we will deal with the generalized form :

Find $$\lambda\in\mathbb{R}$$such that $$Ax = \lambda Bx$$

A standard problem is Hermitian if the matrix $$A$$ is Hermitian ($$A=A^*$$). +
A generalized problem is Hermitian if the matrices $$A$$ and $$B$$ are Hermitian and if $$B$$ is positive definite. +
If the problem is Hermitian, then the eigenvalues are real.
A special case of the generalized problem is when the matrices are not Hermitian but \(B\) is positive definite.

The type of the problem can be specified using the EigenProblemType, or at run time with the command line option `--solvereigen.problem` and the following value :

.Table of problem type
[options="header"]
|===
| Problem type | EigenProblemType | command line key
|Standard Hermitian | HEP | "hep"
|Standard non-Hermitian | NHEP | "nhep"
|Generalized Hermitian | GHEP | "ghep"
|Generalized non-Hermitian | GNHEP | "gnhep"
|Positive definite Generalized non-Hermitian | PGNHEP | "pgnhep"
|===

== Position of spectrum

One can choose which eigenpairs will be computed. The user can set it programmatically with `PositionOfSpectrum` or at run time with the command line option `--solvereigen.spectrum` and the following value :

.Table of position of spectrum
[options="header"]
|===
|Position of spectrum | PositionOfSpectrum | command line key
|Largest magnitude | LARGEST_MAGNITUDE | "largest_magnitude"
|Smallest magnitude | SMALLEST_MAGNITUDE | "smallest_magnitude"
|Largest real | LARGEST_REAL | "largest_real"
|Smallest real | SMALLEST_REAL | "smallest_real"
|Largest imaginary | LARGEST_IMAGINARY | "largest_imaginary"
|Smallest imaginary | SMALLEST_IMAGINARY | "smallest_imaginary"
|===

== Spectral transformation

It is observed that the algorithms used to solve the eigenvalue problems find solutions at the extremities of the spectrum. To improve the convergence, one need to compute the eigenpairs of a transformed operator. Those spectral transformations allow to compute solutions that are not on the boundary of the spectrum.

There are 3 types of spectral transformation:

Shift:: $$A-\sigma I$$ or $$B^{-1}A-\sigma I$$
Shift and invert:: $$(A-\sigma I)^{-1}$$ or $$(A-\sigma B)^{-1}B$$
Cayley:: $$(A-\sigma I)^{-1}(A+\nu I)$$ or $$(A-\sigma B)^{-1}(A+\nu B)$$

By default, shift and invert is used. You can change it with `--solvereigen.transform`.

.Table of spectral transformation
[options="header"]
|===
| Spectral transformation | SpectralTransformationType | command line key
| Shift | SHIFT | shift
| Shift and invert | SINVERT | shift_invert
| Cayley | CAYLEY | cayley
|===

== Eigensolvers



== Special cases of spectrum
